package com.zagorski.room.model.generator.processor

import com.google.auto.service.AutoService
import com.squareup.kotlinpoet.*
import com.zagorski.room.model.generator.annotations.*
import java.io.File
import javax.annotation.processing.*
import javax.lang.model.SourceVersion
import javax.lang.model.element.Element
import javax.lang.model.element.TypeElement
import javax.lang.model.util.ElementFilter
import javax.tools.Diagnostic
import kotlin.reflect.jvm.internal.impl.name.FqName
import kotlin.reflect.jvm.internal.impl.platform.JavaToKotlinClassMap


@AutoService(Processor::class)
@SupportedSourceVersion(SourceVersion.RELEASE_8)
@SupportedOptions(RoomModelProcessor.KAPT_KOTLIN_GENERATED_OPTION_NAME)
class RoomModelProcessor : AbstractProcessor() {

    companion object {
        const val KAPT_KOTLIN_GENERATED_OPTION_NAME = "kapt.kotlin.generated"
    }

    /**
     * Room supported annotations
     */
    private val entityRoomAnnotation = ClassName("androidx.room", "Entity")
    private val columnInfoRoomAnnotation = ClassName("androidx.room", "ColumnInfo")
    private val primaryKeyRoomAnnotation = ClassName("androidx.room", "PrimaryKey")
    private val ignoreRoomAnnotation = ClassName("androidx.room", "Ignore")
    private val embeddedRoomAnnotation = ClassName("androidx.room", "Embedded")
    private val foreignKeyRoomAnnotation = ClassName("androidx.room", "ForeignKey")

    override fun process(annotations: MutableSet<out TypeElement>, roundEnv: RoundEnvironment): Boolean {
        roundEnv.getElementsAnnotatedWith(RoomEntities::class.java).forEach { element ->
            getGeneratedSourcesRoot()?.let {
                val file = File(it)
                file.mkdir()
                val extensionsFileBuilder = FileSpec.builder("", "room_model_generator_extensions")
                ElementFilter.fieldsIn(element.enclosedElements).forEach {
                    val classTypeElement = processingEnv.elementUtils.getTypeElement(it.asType().toString())
                    generateClass(classTypeElement, processingEnv.elementUtils.getPackageOf(classTypeElement).toString(), file)?.let { (classType, classPackage) ->
                        extensionsFileBuilder
                                .addFunction(entityFunctionGenerator(classTypeElement, classType, classPackage))
                                .addFunction(listOfModelsToEntities(classTypeElement))
                                .addFunction(listOfEntitiesToModels(classTypeElement, classType, classPackage))
                    }
                }

                extensionsFileBuilder
                        .build()
                        .writeTo(file)
            }
        }
        return false
    }

    override fun getSupportedAnnotationTypes(): MutableSet<String> = mutableSetOf(RoomEntities::class.java.canonicalName)

    private fun generateClass(classElement: Element, packageOfClass: String, file: File): Pair<TypeSpec, String>? {
        if (classElement.getAnnotation(RoomEntity::class.java) == null) {
            processingEnv.messager.printMessage(Diagnostic.Kind.ERROR, "${classElement.simpleName} is not annotated as `@RoomEntity` and its added to `RoomEntities` data class. Either remove it or put proper annotation.")
            return null
        }

        val typeSpecBuilder = TypeSpec.classBuilder("${classElement.simpleName}Room")
                .addModifiers(KModifier.DATA)
        val constructorFieldsBuilder = FunSpec.constructorBuilder()

        val fieldsIn = ElementFilter.fieldsIn(classElement.enclosedElements)

        val hasPrimaryKeyAnnotation = fieldsIn.any { it.getAnnotation(RoomPrimaryKey::class.java) != null }
        val hasPrimaryKeyAtAll = if (!hasPrimaryKeyAnnotation) fieldsIn.any { it.simpleName.toString() == "id" } else true
        if (!hasPrimaryKeyAtAll) {
            processingEnv.messager.printMessage(Diagnostic.Kind.ERROR, "${classElement.simpleName} is missing primary key. You can define it by either using annotation @RoomPrimaryKey or naming field `id`")
            return null
        }

        fieldsIn.forEach {
            constructorFieldsBuilder.addParameter(it.simpleName.toString(), it.javaToKotlinType())

            val primaryKeyAnnotation = it.getAnnotation(RoomPrimaryKey::class.java)

            val annotations = listOf(AnnotationSpec.builder(columnInfoRoomAnnotation)
                    .addMember("name = %S", it.getAnnotation(RoomName::class.java)?.name
                            ?: it.simpleName.toString()).build())
                    .plusIf({ AnnotationSpec.builder(primaryKeyRoomAnnotation).addMember("autoGenerate = %L", primaryKeyAnnotation.autoGenerated).build() }) { primaryKeyAnnotation != null }
                    .plusIf({ AnnotationSpec.builder(primaryKeyRoomAnnotation).build() }) { !hasPrimaryKeyAnnotation && it.simpleName.toString() == "id" }
                    .plusIf({ AnnotationSpec.builder(ignoreRoomAnnotation).build() }) { it.getAnnotation(RoomIgnore::class.java) != null }
                    .plusIf({ AnnotationSpec.builder(embeddedRoomAnnotation).build() }) { it.getAnnotation(RoomEmbedded::class.java) != null }

            typeSpecBuilder.addProperty(PropertySpec.builder(it.simpleName.toString(), it.javaToKotlinType())
                    .initializer(it.simpleName.toString())
                    .addAnnotations(annotations)
                    .build())
        }

        val tableName = classElement.getAnnotation(RoomEntity::class.java).tableName
        val classAnnotationBuilder = AnnotationSpec.builder(entityRoomAnnotation)
        addForeignKeysAnnotation(classAnnotationBuilder, classElement)
        if (!tableName.isEmpty()) {
            classAnnotationBuilder
                    .addMember("tableName = %S", tableName)
        }

        val classSpec = typeSpecBuilder
                .primaryConstructor(constructorFieldsBuilder.build())
                .addAnnotation(classAnnotationBuilder.build())
                .addFunction(FunSpec.builder("model")
                        .returns(classElement.javaToKotlinType())
                        .addStatement("return %T(${fieldsIn.joinToString(separator = ", ") { "%L" }})", classElement.javaToKotlinType(), *fieldsIn.map { it.simpleName.toString() }.toTypedArray())
                        .build())
                .build()

        FileSpec.builder(packageOfClass, "${classElement.simpleName}Room")
                .addType(classSpec)
                .build()
                .writeTo(file)

        return classSpec to packageOfClass
    }

    private fun entityFunctionGenerator(annotatedClass: Element, classType: TypeSpec, classPackage: String): FunSpec {
        val fieldsIn = ElementFilter.fieldsIn(annotatedClass.enclosedElements)
        return FunSpec.builder("entity")
                .receiver(annotatedClass.javaToKotlinType())
                .addAnnotation(AnnotationSpec.builder(JvmName::class)
                        .addMember("%S", "${annotatedClass.simpleName}-entity").build())
                .addStatement("return %T(${fieldsIn.joinToString(separator = ", ") { "%L" }})", ClassName.bestGuess("$classPackage.${classType.name}"), *fieldsIn.map { it.simpleName.toString() }.toTypedArray())
                .build()

    }

    private fun listOfModelsToEntities(annotatedClass: Element): FunSpec {
        return FunSpec.builder("entities")
                .receiver(ParameterizedTypeName.get(List::class.asClassName(), annotatedClass.javaToKotlinType()))
                .addAnnotation(AnnotationSpec.builder(JvmName::class)
                        .addMember("%S", "${annotatedClass.simpleName}-entities").build())
                .addStatement("return map { it.entity() }")
                .build()
    }

    private fun listOfEntitiesToModels(annotatedClass: Element, classType: TypeSpec, classPackage: String): FunSpec {
        return FunSpec.builder("models")
                .receiver(ParameterizedTypeName.get(List::class.asClassName(), ClassName.bestGuess("$classPackage.${classType.name}")))
                .addAnnotation(AnnotationSpec.builder(JvmName::class)
                        .addMember("%S", "${annotatedClass.simpleName}-models").build())
                .addStatement("return map { it.model() }")
                .build()
    }

    private fun addForeignKeysAnnotation(classAnnotationBuilder: AnnotationSpec.Builder, tmpClass: Element) {
        val foreignKeysAnnotation = tmpClass.getAnnotation(RoomForeignKeys::class.java)
        foreignKeysAnnotation?.let {
            val foreignKeysArray = arrayOf<AnnotationSpec>().plus(it.foreignKeys.map {
                AnnotationSpec.builder(foreignKeyRoomAnnotation)
                        .addMember("entity = %L", "${it.entityClassName}Room::class")
                        .addMember("parentColumns = [${it.parentColumns.joinToString(separator = ", ") { "%S" }}]", *it.parentColumns)
                        .addMember("childColumns = [${it.childColumns.joinToString(separator = ", ") { "%S" }}]", *it.childColumns)
                        .build()
            })
            if (!foreignKeysArray.isEmpty()) {
                classAnnotationBuilder
                        .addMember("foreignKeys = [${foreignKeysArray.joinToString(separator = ", ") { "%L" }}]", *foreignKeysArray)
            }
        }
    }

    private fun getGeneratedSourcesRoot(): String? {
        val generatedSourcesRoot = processingEnv.options[KAPT_KOTLIN_GENERATED_OPTION_NAME].orEmpty()
        if (generatedSourcesRoot.isEmpty()) {
            processingEnv.messager.printMessage(Diagnostic.Kind.ERROR, "Can't find the target directory for generated Kotlin files.")
            return null
        }
        return generatedSourcesRoot
    }

    private fun <T> List<T>.plusIf(item: () -> T, f: () -> Boolean): List<T> = if (f()) plus(item()) else this

    private fun Element.javaToKotlinType(): TypeName = asType().asTypeName().javaToKotlinType()

    private fun TypeName.javaToKotlinType(): TypeName {
        return if (this is ParameterizedTypeName) {
            ParameterizedTypeName.get(rawType.javaToKotlinType() as ClassName, *typeArguments.map { it.javaToKotlinType() }.toTypedArray())
        } else {
            val className = JavaToKotlinClassMap.INSTANCE.mapJavaToKotlin(FqName(toString()))?.asSingleFqName()?.asString()
            return if (className == null) {
                this
            } else {
                ClassName.bestGuess(className)
            }
        }
    }

}